// Generated by the C++ Middleware Writer version 1.10

#include <boost/circular_buffer.hpp>
#include <MarshallingFunctions.hh>
#include <ReceiveCompressedBuffer.hh>
#include <SendCompressedBuffer.hh>

using boost::circular_buffer;
extern uint32_t msg_length_max;

struct msgs
{

void
Send(SendCompressedBuffer* buf, const circular_buffer<uint32_t>& abt1)
{
  Counter cntr(msg_length_max);
  cntr.Add(sizeof(uint32_t));
  cntr.Add(sizeof(uint32_t));
  blockCount(cntr, abt1);

  buf->Receive(&cntr.value_, sizeof(cntr.value_));
  buf->Receive32(abt1.capacity());
  buf->Receive32(abt1.size());
  auto mediator2 = abt1.begin();
  //circular_buffer<uint32_t >::const_iterator mediator2 = abt1.begin();
  circular_buffer<uint32_t >::const_iterator omega2 = abt1.end();
  for (; mediator2 != omega2; ++mediator2) {
    buf->Receive(&(*mediator2), sizeof(uint32_t));
  }
  buf->Flush();
} 


template <typename B>
void
Receive(B* buf, circular_buffer<uint32_t>& abt1)
{
  uint32_t headCount[1];
  uint32_t cap2;
  buf->Give(cap2);
  abt1.set_capacity(cap2);
  buf->Give(headCount[0]);
  while (headCount[0] > 0) {
    --headCount[0];
    uint32_t rep3;
    buf->Give(rep3);
    abt1.push_back(rep3);
  }
} 

};


